//! Turning values into byte slices and back, for the [`Stack`](crate::Stack)

use core::marker::PhantomData;
use serde::de::DeserializeOwned;

/// Helper to turn strongly typed data structures into raw bytes
///
/// Used primarily when throwing values onto and fetching them from the [`Stack`](crate::Stack)
pub trait Serializer {
    type Error;

    fn serialize<R, T: serde::Serialize>(
        &self,
        value: &T,
        callback: impl FnOnce(&[u8]) -> R,
    ) -> Result<R, Self::Error>;

    fn deserialize<T: DeserializeOwned>(&self, buf: &[u8]) -> Result<T, Self::Error>;
}

/// Turns types into JSON using [`serde_json`](`serde_json`)
#[cfg(feature = "alloc")]
#[derive(Clone, Copy)]
pub struct JsonSerializer;

#[cfg(feature = "alloc")]
impl Serializer for JsonSerializer {
    type Error = serde_json::Error;

    fn serialize<R, T: serde::Serialize>(
        &self,
        value: &T,
        callback: impl FnOnce(&[u8]) -> R,
    ) -> Result<R, Self::Error> {
        let buffer = serde_json::to_vec(value)?;
        Ok((callback)(buffer.as_slice()))
    }

    fn deserialize<T: DeserializeOwned>(&self, buf: &[u8]) -> Result<T, Self::Error> {
        serde_json::from_slice(buf)
    }
}

/// Errors that may occur while transmuting raw memory into types
#[derive(Debug)]
pub enum TransmuteError {
    /// Source slice did not have enough bytes available to deserialize into the given type
    NotEnoughBytes,
}

/// Transmutes types to and from byte slices through `unsafe` crimes
///
/// # ⚠️ Safety warning — Here be dragons!
///
/// **You should *never* instantiate this in your own code.**
///
/// This serializer is only memory safe under a strict set of preconditions.
/// It is exclusively instantiated in the code generated by the [`AsyncExecutionQueue`](stabg_derive::AsyncExecutionQueue)
/// derive macro where these intrinsics are fulfilled.
///
/// YOU HAVE BEEN WARNED!
#[derive(Clone, Copy)]
pub struct TransmuteSerializer(PhantomData<()>);

impl TransmuteSerializer {
    /// Creates a new instance. You really should not.
    ///
    /// # Safety
    ///
    /// This serializer is only safe if you **always** provide bytes that actually match the to-be-deserialized type.
    /// If you do not, then it *will* result in undefined behaviour.
    pub unsafe fn new() -> Self {
        Self(PhantomData)
    }
}

impl Serializer for TransmuteSerializer {
    type Error = TransmuteError;

    fn serialize<R, T: serde::Serialize>(
        &self,
        value: &T,
        callback: impl FnOnce(&[u8]) -> R,
    ) -> Result<R, Self::Error> {
        let ptr = value as *const T as *const u8;
        let len = core::mem::size_of::<T>();
        let slice = unsafe { core::slice::from_raw_parts(ptr, len) };

        Ok((callback)(slice))
    }

    fn deserialize<T: DeserializeOwned>(&self, buf: &[u8]) -> Result<T, Self::Error> {
        let len = core::mem::size_of::<T>();

        if buf.len() < len {
            Err(Self::Error::NotEnoughBytes)
        } else {
            let mut value = core::mem::MaybeUninit::<T>::zeroed();
            let ptr = value.as_mut_ptr() as *mut u8;
            let slice = unsafe { core::slice::from_raw_parts_mut(ptr, len) };

            slice.copy_from_slice(&buf[0..len]);

            Ok(unsafe { value.assume_init() })
        }
    }
}

#[cfg(all(test, feature = "derive"))]
mod does {
    use super::*;
    use serde::{Deserialize, Serialize};

    #[derive(Serialize, Deserialize, PartialEq, Debug)]
    struct Inner(f64);

    #[derive(Serialize, Deserialize, PartialEq, Debug)]
    struct Outer(u32, Inner, i16);

    #[test]
    fn survive_transmute_roundtrip() {
        let serializer = unsafe { TransmuteSerializer::new() };
        let value = Outer(42, Inner(133.7), -42);

        serializer
            .serialize(&value, |buf| {
                let new_value: Outer = serializer.deserialize(buf).unwrap();
                assert_eq!(new_value, value);
            })
            .unwrap();
    }
}
